# Build my own SQLite database
https://cstack.github.io/db_tutorial/parts/part3.html
### Random Notes
- Non-SQL statements like .exit are called “meta-commands”. They all start with a dot, so we check for them and handle them in a separate function.
- `offset`: In database structure, an offset typically refers to the physical position or displacement of data within the storage system. Here are the key points:
  1. File / Page Level:
     - Offset indicates the exact byte position where data begins within the database file or page
     - Used to locate and retrieve specific records quickly
     - Helps in organizing data blocks and manage storage space
  2. Record Structure:
     - Points to the position of fields/columns withing a record
     - Used for calculating where each field's data begins and ends
     - Helps maintain fixed or variable-length record formats
  3. Index usage:
     - Helps maintain pointer structures in indexes
     - Used for quick data retrieval without scanning entire tables
     - Stores physical locations of data rows

  | column    | size (bytes) | offset |
  |-----------|:------------:|:------:|
  | id        |      4       |   0    |
  | username  |      32      |   34   |
  | email     |     255      |   36   |  
  | **total** |   **291**    |        |
- `arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`
- When creating table, rows should not cross page boundaries. Since pages probably won't exist next to each other in memory, this assumption makes it easier to read/write rows.

### SQLite architecture
&ensp;&ensp;`Tokenizer`  
&emsp;&emsp;&emsp;↓  
&emsp;&ensp;`Parser`  
&emsp;&emsp;&emsp;↓  
`Code Generator`  
&emsp;&emsp;&emsp;↓  
`Virtual Machine`  
&emsp;&emsp;&emsp;↓  
&emsp;&ensp;`B-Tree`  
&emsp;&emsp;&emsp;↓  
&emsp;&ensp;&ensp;`Pager`  
&emsp;&emsp;&emsp;↓  
`Os Interface`    

**Tokenizer** *front-end*: 
- Breaks SQL queries into tokens (lexical analysis)
- Identifies keywords, operators, identifiers, literals
- Removes whitespace and comments
- Prepares inputs for the parsers stage

**Parser** *front-end*:
- Creates syntax tree from tokens
- Validates SQL grammar and syntax
- Enforces SQL language rules
- Generates internal representation of the query

**Code Generator** *front-end*:
- Converts parser's syntax tree into bytecode
- Optimizes operations where possible
- Creates executable instructions for Virtual Machine
- Handles query planning and optimization

**Virtual Machine** *back-end*:  
The virtual machine takes bytecode generated by the front-end as instructions. It can then perform operations on one or more tables or indexes, each of which is stored in a data structure called a B-tree. The VM is essentially a big switch statement on the type of bytecode instruction.
- Executes bytecode instructions
- Core processing engine
- Manages program flow and control
- Interfaces with B-Tree for data access

**B-Tree** *back-end*:  
Each B-tree consists of many nodes. Each node is one page in length. The B-tree can retrieve a page from disk or save it back to disk by issuing commands to the pager
- Primary data structure for tables and indexes
- Maintains sorted data for efficient access
- Handles:
  - Data insertion
  - Deletion
  - Balanced tree maintenance
  - Range queries
  - Index lookups

**Pager** *back-end*:  
The pager receives commands to read or write pages of data. It is responsible for reading/writing at appropriate offsets in the database file. It also keeps a cache of recently-accessed pages in memory, and determines when those pages need to be written back to disk.
- Manages database pages in memory
- Handles:
  - Cache managment
  - Transaction control
  - Write-ahead logging
  - Data persistence
  - Memory mapping

**OS Interface** *back-end*:  
The os interface is the layer that differs depending on which operating system sqlite was compiled for.
- Abstracts operating system operations
- Manages:
  - File operations
  - Memory allocations
  - System calls
  - Cross-platform compatibility
  - Lock management
